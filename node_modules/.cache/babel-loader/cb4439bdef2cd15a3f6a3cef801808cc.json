{"ast":null,"code":"class Node {\n  constructor(value) {\n    this.id = `Tile-${value}`;\n    this.value = value;\n    this.width = 2 * value;\n    this.next = null;\n  }\n\n}\n\nclass Stack {\n  constructor(length) {\n    this.size = 0;\n    this.maxSize = length;\n    this.top = null;\n  }\n\n  push(disk) {\n    let newNode = new Node(); //Agregar el elemento solamente si la pila aún no está llena\n\n    if (this.size !== this.maxSize && !this.top) {\n      //Podemos agregar el elemento en la pila\n      this.top = newNode;\n    } else if (this.size !== this.maxSize && this.top) {\n      newNode.next = this.top;\n      this.top = newNode;\n    } else {\n      return console.log('Error: la pila está llena');\n    }\n\n    this.size++;\n    return this;\n  }\n\n  pop() {\n    //1. Cuando no nos queden elementos en nuestra estructura de datos\n    if (this.size === 0) {\n      return null;\n    } //2. Cuando tengamos elementos en nuestra estructura de datos\n\n\n    const topNode = this.top;\n    this.top = this.top.next;\n    this.size--;\n    return topNode;\n  } //pop() {\n  //  if(!this.top.next){\n  //    this.size--\n  //    console.log(\"debe entrar\", this.size)\n  //    return null\n  //  }\n  //  this.top = this.top.next\n  //  this.size--\n  //  return this.top\n  //}\n\n\n  peek() {\n    if (!this.top) {\n      return null;\n    }\n\n    return this.top.value;\n  }\n\n  isFull() {\n    return this.size === this.maxSize;\n  }\n\n  isEmpty() {\n    return this.size === 0;\n  }\n\n  traverse() {\n    //Obtener una lista con todos los nodos de la pila\n    let currentNode = this.top;\n    let list = [];\n\n    while (currentNode) {\n      let tempNode = Object.assign({}, currentNode);\n      tempNode.next = null;\n      list.push(tempNode);\n      currentNode = currentNode.next;\n    }\n\n    return list;\n  }\n\n}\n\nexport default Stack;","map":{"version":3,"names":["Node","constructor","value","id","width","next","Stack","length","size","maxSize","top","push","disk","newNode","console","log","pop","topNode","peek","isFull","isEmpty","traverse","currentNode","list","tempNode","Object","assign"],"sources":["/home/editorial/Descargas/Robert/src/utils/Stack.js"],"sourcesContent":["class Node {\r\n  constructor(value) {\r\n    this.id = `Tile-${value}`;\r\n    this.value = value;\r\n    this.width = 2 * value;\r\n    this.next = null;\r\n  }\r\n}\r\n\r\nclass Stack {\r\n  constructor(length) {\r\n    this.size=0\r\n    this.maxSize = length\r\n    this.top = null\r\n  }\r\n\r\n  push(disk) {\r\n    let newNode = new Node();\r\n    //Agregar el elemento solamente si la pila aún no está llena\r\n    if (this.size !== this.maxSize && !this.top) {\r\n      //Podemos agregar el elemento en la pila\r\n      this.top = newNode;\r\n    } else if (this.size !== this.maxSize && this.top) {\r\n      newNode.next = this.top;\r\n      this.top = newNode;\r\n    } else {\r\n      return console.log('Error: la pila está llena');\r\n    }\r\n    this.size++;\r\n    return this;\r\n  }\r\n\r\n  pop() {\r\n    //1. Cuando no nos queden elementos en nuestra estructura de datos\r\n    if (this.size === 0) {\r\n      return null;\r\n    }\r\n    //2. Cuando tengamos elementos en nuestra estructura de datos\r\n    const topNode = this.top;\r\n    this.top = this.top.next;\r\n    this.size--;\r\n    return topNode;\r\n  }\r\n\r\n  //pop() {\r\n  //  if(!this.top.next){\r\n  //    this.size--\r\n  //    console.log(\"debe entrar\", this.size)\r\n  //    return null\r\n  //  }\r\n  //  this.top = this.top.next\r\n  //  this.size--\r\n  //  return this.top\r\n  //}\r\n\r\n  peek() {\r\n    if(!this.top){\r\n      return null\r\n    }\r\n      return this.top.value\r\n  }\r\n\r\n  isFull() {\r\n    return this.size === this.maxSize;\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.size === 0;\r\n  }\r\n\r\n\r\n  traverse() {\r\n    //Obtener una lista con todos los nodos de la pila\r\n    let currentNode = this.top;\r\n    let list = [];\r\n    while (currentNode) {\r\n      let tempNode = Object.assign({}, currentNode);\r\n      tempNode.next = null;\r\n      list.push(tempNode);\r\n      currentNode = currentNode.next;\r\n    }\r\n    return list;\r\n  }\r\n}\r\n\r\nexport default Stack;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"mappings":"AAAA,MAAMA,IAAN,CAAW;EACTC,WAAW,CAACC,KAAD,EAAQ;IACjB,KAAKC,EAAL,GAAW,QAAOD,KAAM,EAAxB;IACA,KAAKA,KAAL,GAAaA,KAAb;IACA,KAAKE,KAAL,GAAa,IAAIF,KAAjB;IACA,KAAKG,IAAL,GAAY,IAAZ;EACD;;AANQ;;AASX,MAAMC,KAAN,CAAY;EACVL,WAAW,CAACM,MAAD,EAAS;IAClB,KAAKC,IAAL,GAAU,CAAV;IACA,KAAKC,OAAL,GAAeF,MAAf;IACA,KAAKG,GAAL,GAAW,IAAX;EACD;;EAEDC,IAAI,CAACC,IAAD,EAAO;IACT,IAAIC,OAAO,GAAG,IAAIb,IAAJ,EAAd,CADS,CAET;;IACA,IAAI,KAAKQ,IAAL,KAAc,KAAKC,OAAnB,IAA8B,CAAC,KAAKC,GAAxC,EAA6C;MAC3C;MACA,KAAKA,GAAL,GAAWG,OAAX;IACD,CAHD,MAGO,IAAI,KAAKL,IAAL,KAAc,KAAKC,OAAnB,IAA8B,KAAKC,GAAvC,EAA4C;MACjDG,OAAO,CAACR,IAAR,GAAe,KAAKK,GAApB;MACA,KAAKA,GAAL,GAAWG,OAAX;IACD,CAHM,MAGA;MACL,OAAOC,OAAO,CAACC,GAAR,CAAY,2BAAZ,CAAP;IACD;;IACD,KAAKP,IAAL;IACA,OAAO,IAAP;EACD;;EAEDQ,GAAG,GAAG;IACJ;IACA,IAAI,KAAKR,IAAL,KAAc,CAAlB,EAAqB;MACnB,OAAO,IAAP;IACD,CAJG,CAKJ;;;IACA,MAAMS,OAAO,GAAG,KAAKP,GAArB;IACA,KAAKA,GAAL,GAAW,KAAKA,GAAL,CAASL,IAApB;IACA,KAAKG,IAAL;IACA,OAAOS,OAAP;EACD,CAjCS,CAmCV;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EAEAC,IAAI,GAAG;IACL,IAAG,CAAC,KAAKR,GAAT,EAAa;MACX,OAAO,IAAP;IACD;;IACC,OAAO,KAAKA,GAAL,CAASR,KAAhB;EACH;;EAEDiB,MAAM,GAAG;IACP,OAAO,KAAKX,IAAL,KAAc,KAAKC,OAA1B;EACD;;EAEDW,OAAO,GAAG;IACR,OAAO,KAAKZ,IAAL,KAAc,CAArB;EACD;;EAGDa,QAAQ,GAAG;IACT;IACA,IAAIC,WAAW,GAAG,KAAKZ,GAAvB;IACA,IAAIa,IAAI,GAAG,EAAX;;IACA,OAAOD,WAAP,EAAoB;MAClB,IAAIE,QAAQ,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBJ,WAAlB,CAAf;MACAE,QAAQ,CAACnB,IAAT,GAAgB,IAAhB;MACAkB,IAAI,CAACZ,IAAL,CAAUa,QAAV;MACAF,WAAW,GAAGA,WAAW,CAACjB,IAA1B;IACD;;IACD,OAAOkB,IAAP;EACD;;AAzES;;AA4EZ,eAAejB,KAAf"},"metadata":{},"sourceType":"module"}